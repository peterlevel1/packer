var util = require('util')
	, Promise = require('promise')
	, core_slice = Array.prototype.slice
	, SIG_STOP = 1
	, I_MAX = 10000
	, _ = {};

module.exports = _;

_.hasError = function (e) {
	return util.isError(e) || e === false;
};

_.onlyOnce = function (callback) {
	var hasCalled = false,
		name = (callback && callback.name) || 'NO_NAME';
	callback = callback || _.noop;
	return function () {
		if (hasCalled) {
			throw new Error("callback " + name + " has already been called.");
		}
		hasCalled = true;
		callback.apply(null, core_slice.call(arguments));
	};
};

_.series = function(arr, iterator, callback) {
	arr = arr.slice();

	var	complete = 0,
		done = _.onlyOnce(callback),
		results = [];

	(function next(error, value) {
		if (complete > 0) {
			results.push(value);
		}

		if (_.hasError(error)) {
			done(error);
		}
		else if (error === SIG_STOP || complete >= arr.length) {
			done(null, results);
		}
		else {
			iterator(arr[complete++], next);
		}
	})();

	return arr;
};

/**
 * @param: done {Function} : 1st time: hold it, but should'nt set next
 * @param: next {Function} : iterate the walk route, with {done} as the last
 */

_.seriesCallback = function (next, done) {
	return function (error, value) {
		if (_.hasError(error)) {
			done(error);
		}
		else {
			if (next) {
				next(null, value);
			}
			else {
				done(null, value);
			}
		}
	};
};

_.parellel = function (arr, iterator, callback) {
	arr = arr.slice();

	var length = arr.length,
		complete = 0,
		hasError = false,
		hasDone = false,
		results = [],
		done = _.onlyOnce(callback),
		next = function (error, value) {
			complete++;
			results.push(value);

			if (_.hasError(error)) {
				hasError = true;
				done(error);
			}
			else if (error === SIG_STOP || complete >= length) {
				hasDone = true;
				done(null, results);
			}
		},
		progress = function (value) {
			if (!hasError && !hasDone) {
				iterator(value, next);
			}
		};

	arr.forEach(progress);
};

_.parellelCallback = _.seriesCallback;

_.memory = function (asyncFn, ctx) {
	return function (value, done, fail) {

		var promise = new Promise(function (s, f) {
			function memoryDone (e, v) {
				if (_.hasError(e)) {
					f(e);
				}
				else {
					if (arguments.length <= 2) {
						s(v);
					}
					else {
						s(core_slice.call(arguments, 1));
					}
				}
			}

			if (_.hasError(value)) {
				f(value);
			}
			else if (util.isArray(value)) {
				if (_.hasError(value[0])) {
					f(value[0]);
				}
				else {
					asyncFn.apply((ctx || null), value.concat(memoryDone));
				}
			}
			else {
				asyncFn(value, memoryDone);
			}
		});

		if (done || fail) {
			return promise.then(done, fail);
		}

		return promise;
	};
};
