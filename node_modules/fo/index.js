
var path = require('path')
	,	fs = require('fs')
	,	_ = require('simpleAsync')
	, series = _.series
	, seriesCallback = _.seriesCallback
	, onlyOnce = _.onlyOnce
	, rDefaultFilter = /(temp|svn|git|tag)/i
	, fo = {};

module.exports = fo;

fo._ = _;

[	'readdir',
 	'stat',
 	'open',
 	'close',
 	'writeFile',
 	'readFile',
 	'exists',
 	'mkdir' ].forEach(function (fsMethodName) {
	fo[fsMethodName] = _.memory(fsWrapper(fs[fsMethodName]));
});

function fsWrapper(fsMethod) {
	return function () {
		arguments[0] = String(arguments[0]);
		return fsMethod.apply(fs, arguments);
	};
}

fo.lockdir = function (dir) {
	return function (filename) {
		return path.join(dir, filename);
	};
};

fo.walkdir = function walkdir(dir, fileCallback, dirCallback, done, /**/next ) {
	if (!next) {
		done = onlyOnce(done);
	}

	var seriesNextDone = seriesCallback(next, done)
		, dir = !path.isAbsolute(dir)
				? path.resolve(dir)
				: dir;

	if (dirCallback && dirCallback(dir) === false) {
		return seriesNextDone(null);
	}

	fo.readdir(dir)
	.then(function (filenames) {
		filenames = filenames.map(fo.lockdir(dir));
		series(filenames, function (filename, _next) {
			fo.stat(filename)
			.then(function (stats) {
				if (stats.isDirectory()) {
					//***_next : remember this floor's next file
					walkdir(filename, fileCallback, dirCallback, done, _next);
				}
				else if (stats.isFile()) {
					if (!fileCallback) {
						_next(null);
					}
					else if (fileCallback.length <= 1) {
						fileCallback(filename);
						_next(null);
					}
					else {
						fileCallback(filename, _next);
					}
				}
				 //******
			}, _next);
			 //******
		}, seriesNextDone);
		 //******
	}, done);
};

fo.mapdir = function (root, str) {
	return path.join(str).split(path.sep).map(function (subdir, index, arr) {
		return path.join.apply(path, [root].concat(arr.slice(0, index + 1)));
	});
};

fo.gendir = function (dirs, callback) {
	series(dirs, function (dir, next) {
		fo.exists(dir).then(next, function () {
			fo.mkdir(dir).always(next);
		});
	}, callback);
};

fo.writeChunks = function (writer, chunks, callback) {
  var i = 0,
    length = chunks.length;

  (function write() {
    var ok = true,
      chunk;
    while (i < length && ok) {
      chunk = chunks[i++];
      if (i === length) {
      	writer.write(chunk, null, callback);
      } else {
        ok = writer.write(chunk);
      }
    }
    if (i < length) {
    	writer.once('drain', write);
    }
  })();
};

var watchList = [];
/**
 * Watch for changes on path
 */
fo.watchFile = function (fn) {
  return function (url, base) {
    url = path.normalize(url);

    if (watchList.indexOf(url) !== -1) {
      return;
    }
    watchList.push(url);

    console.log("  \033[90mwatching \033[36m%s\033[0m", url);

    var opts = {
        persistent: true,
        interval: 200
      },
      callback = function (curr, prev) {
        // File doesn't exist anymore. Keep watching.
        if (curr.mtime.getTime() === 0) {
          return;
        }
        // istanbul ignore if
        if (curr.mtime.getTime() === prev.mtime.getTime()) {
          return;
        }
        fn(url, base);
      };
    fs.watchFile(url, opts, callback);
  };
};

var fsKeys =
	[ 'Stats',
  'F_OK',
  'R_OK',
  'W_OK',
  'X_OK',
  'access',
  'accessSync',
  'exists',
  'existsSync',
  'readFile',
  'readFileSync',
  'close',
  'closeSync',
  'open',
  'openSync',
  'read',
  'readSync',
  'write',
  'writeSync',
  'rename',
  'renameSync',
  'truncate',
  'truncateSync',
  'ftruncate',
  'ftruncateSync',
  'rmdir',
  'rmdirSync',
  'fdatasync',
  'fdatasyncSync',
  'fsync',
  'fsyncSync',
  'mkdir',
  'mkdirSync',
  'readdir',
  'readdirSync',
  'fstat',
  'lstat',
  'stat',
  'fstatSync',
  'lstatSync',
  'statSync',
  'readlink',
  'readlinkSync',
  'symlink',
  'symlinkSync',
  'link',
  'linkSync',
  'unlink',
  'unlinkSync',
  'fchmod',
  'fchmodSync',
  'chmod',
  'chmodSync',
  'fchown',
  'fchownSync',
  'chown',
  'chownSync',
  '_toUnixTimestamp',
  'utimes',
  'utimesSync',
  'futimes',
  'futimesSync',
  'writeFile',
  'writeFileSync',
  'appendFile',
  'appendFileSync',
  'watch',
  'watchFile',
  'unwatchFile',
  'realpathSync',
  'realpath',
  'createReadStream',
  'ReadStream',
  'FileReadStream',
  'createWriteStream',
  'WriteStream',
  'FileWriteStream',
  'SyncWriteStream' ];
/**
 *
console.log(fs.openSync.toString());
var fd = fs.openSync(__filename, 1);
console.log(fs.fstatSync(fd));


var i = 0, chunks = [];
while (i++ < 10000) {
  chunks.push(i + '');
}

var writer = fs.createWriteStream('./test/t-1.txt', 'a+');

fo.writeChunks(writer, chunks, function () {
  console.log('done');
});
*/